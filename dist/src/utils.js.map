{"version":3,"sources":["utils.js"],"names":["DEBUG","console","log","FILTER_LIST","getMemory","window","performance","memory","setTimeout","isValidHttpUrl","string","url","URL","protocol","_err","promiseSome","arr","predicate","v","arrCopy","slice","length","Promise","arrWithIDs","map","promise","idx","then","op","result","className","includes","catch","race","soon","splice"],"mappings":";AAAA,aA4BO,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,GAAA,GAAA,EAAA,EAAA,MAAA,MAAA,GAAA,YAAA,EAAA,GAAA,EAAA,KAAA,EAAA,GAAA,QAAA,QAAA,GAAA,KAAA,EAAA,GAAA,SAAA,EAAA,GAAA,OAAA,WAAA,IAAA,EAAA,KAAA,EAAA,UAAA,OAAA,IAAA,QAAA,SAAA,EAAA,GAAA,IAAA,EAAA,EAAA,MAAA,EAAA,GAAA,SAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,OAAA,GAAA,SAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,QAAA,GAAA,OAAA,MAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,YAAA,EAAA,QAAA,eAAA,QAAA,YAAA,QAAA,WAAA,EAzBA,IAAMA,GAAQ,EAyBd,QAAA,MAAA,EAxBFA,IACHC,QAAQC,IAAM,cAIT,IAAMC,EAAc,CAAC,SAAU,OAAQ,QAmBvC,QAAA,YAAA,EAjBP,IAAMC,EAAY,SAAZA,IACCJ,IAELC,QAAQC,IAAIG,OAAOC,YAAYC,QAC/BC,WAAW,WAAQJ,KAAe,OAEpCA,IAEO,IAAMK,EAAiB,SAACC,GACzB,IACIC,IAAAA,EAAM,IAAIC,IAAIF,GACbC,MAAiB,UAAjBA,EAAIE,UAAyC,WAAjBF,EAAIE,SACvC,MAAOC,GACA,OAAA,IAIWC,SAAAA,EAAAA,GAAf,OAAA,EAAA,MAAA,KAAA,WAAA,SAAA,IAAA,OAAA,EAAA,EAAA,mBAAA,KAAA,SAA4BC,EAAAA,GAA5B,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,mBAAA,KAAA,SAAA,GAAA,OAAA,OAAA,EAAA,KAAA,EAAA,MAAA,KAAA,EACCC,EAAY,SAACC,GAAMA,OAAAA,GAEnBC,EAAUH,EAAII,MAAM,GAHrB,KAAA,EAMED,IAAAA,EAAQE,OANV,CAAA,EAAA,KAAA,GAAA,MAegBC,OAPbC,EAAaJ,EAAQK,IAAI,SAACC,EAASC,GAChCD,OAAAA,EACJE,KAAK,SAAAC,GAAO,MAAA,CAAEF,IAAAA,EAAKG,OAAQD,EAAG,IAAMA,EAAG,GAAGE,WAAa3B,EAAY4B,SAASH,EAAG,GAAGE,cAClFE,MAAM,SAAAlB,GAAS,MAAA,CAAEY,IAAAA,EAAKG,QAAQ,OAXhC,EAAA,KAAA,EAegBP,QAAQW,KAAKV,GAf7B,KAAA,EAkBCN,GAHEiB,EAfH,EAAA,MAkBCjB,EAAUiB,EAAKL,QAlBhB,CAAA,EAAA,KAAA,EAAA,MAkBgC,OAAA,EAAA,OAAA,UAAA,GAlBhC,KAAA,EAqBHV,EAAQgB,OAAOD,EAAKR,IAAK,GArBtB,EAAA,KAAA,EAAA,MAAA,KAAA,GAyBE,OAAA,EAAA,OAAA,UAAA,GAzBF,KAAA,GAAA,IAAA,MAAA,OAAA,EAAA,SAAA,OAAA,MAAA,KAAA,WAAA,QAAA,eAAA","file":"utils.js","sourceRoot":"../../src","sourcesContent":["'use strict'\n\n// Set DEBUG to true to start logging in the console\nexport const DEBUG = false\nif (!DEBUG) {\n  console.log = () => {}\n}\n\n// the image classes that needs to be filtered\nexport const FILTER_LIST = ['Hentai', 'Porn', 'Sexy']\n\nconst getMemory = () => {\n  if (!DEBUG) return\n\n  console.log(window.performance.memory)\n  setTimeout(() => { getMemory() }, 7000)\n}\ngetMemory()\n\nexport const isValidHttpUrl = (string) => {\n  try {\n    const url = new URL(string)\n    return url.protocol === 'http:' || url.protocol === 'https:'\n  } catch (_err) {\n    return false\n  }\n}\n\nexport async function promiseSome (arr) {\n  const predicate = (v) => v\n  // Don't mutate arguemnts\n  const arrCopy = arr.slice(0)\n\n  // Wait until we run out of Promises\n  while (arrCopy.length) {\n    // Give all our promises IDs so that we can remove them when they are done\n    const arrWithIDs = arrCopy.map((promise, idx) => {\n      return promise\n        .then(op => ({ idx, result: op[0] && op[0].className && FILTER_LIST.includes(op[0].className) }))\n        .catch(_err => ({ idx, result: false }))\n    })\n\n    // Wait for one of the Promises to resolve\n    const soon = await Promise.race(arrWithIDs)\n\n    // If it passes the test, we're done\n    if (predicate(soon.result)) return true\n\n    // Otherwise, remove that Promise and race again\n    arrCopy.splice(soon.idx, 1)\n  }\n\n  // No Promises passed the test\n  return false\n}\n"]}